<!doctype html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="https://i.pinimg.com/1200x/97/1d/bf/971dbf5a9b4249aa231c6993774a89ab.jpg">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>#Colors</title>
  <style>
    :root{
      --bg:#0b0c0f;
      --fg:#f2f2f2;
      --muted:rgba(255,255,255,.65);
      --border:rgba(255,255,255,.12);
      --panel:rgba(255,255,255,.06);
      --shadow: 0 18px 50px rgba(0,0,0,.55);
      --r:16px;
      --pad:16px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";

      /* lines between colors */
      --gridline: rgba(255,255,255,.10);
      --gridgap: 2px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      background: radial-gradient(900px 600px at 20% 0%, rgba(255,183,195,.12), transparent 60%),
                  radial-gradient(900px 600px at 80% 20%, rgba(188,244,222,.10), transparent 55%),
                  var(--bg);
      color:var(--fg);
      overflow:hidden;
    }

    .topbar{
      position:fixed;
      inset: 14px 14px auto 14px;
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px 12px;
      border:1px solid var(--border);
      background: rgba(10,10,14,.55);
      backdrop-filter: blur(10px);
      border-radius: calc(var(--r) + 6px);
      box-shadow: var(--shadow);
      z-index:10;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      white-space:nowrap;
    }
    .dot{
      width:10px;height:10px;border-radius:50%;
      background: linear-gradient(135deg, #ffb7c3, #bcf4de);
      box-shadow: 0 0 0 3px rgba(255,255,255,.06);
    }
    .title{
      font-weight:700;
      letter-spacing:.2px;
      font-size:14px;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
      line-height:1.2;
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      margin-left:auto;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
    }

    .label{
      font-size:12px;
      color:var(--muted);
    }

    input[type="color"]{
      width:36px;
      height:28px;
      border:1px solid var(--border);
      background: transparent;
      border-radius:10px;
      padding:0;
      cursor:pointer;
    }

    /* Toggle (Pastel mode) */
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      user-select:none;
      white-space:nowrap;
    }
    .toggle input{
      width:16px;
      height:16px;
      accent-color: #ffb7c3;
      cursor:pointer;
    }
    .toggle span{
      font-size:12px;
      color: rgba(255,255,255,.85);
      font-weight:650;
    }

    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      color:var(--fg);
      padding:8px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:650;
      font-size:12px;
      transition: transform .08s ease, background .18s ease, border-color .18s ease;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.18); }
    .btn:active{ transform: translateY(1px); }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:11px;
      color: rgba(255,255,255,.75);
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      padding: 2px 7px;
      border-radius: 8px;
    }

    /* LINES BETWEEN COLORS */
    .palette{
      position:absolute;
      inset: 0;
      display:grid;
      grid-template-columns: repeat(6, 1fr);
      gap: var(--gridgap);
      background: var(--gridline);
      padding: var(--gridgap);
    }

    .card{
      position:relative;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding: 22px 18px;
      cursor:pointer;
      user-select:none;
      transition: filter .15s ease;
      border-radius: 10px;
      overflow:hidden;
    }
    .card:hover{ filter: brightness(1.03); }

    .card::after{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(to top, rgba(0,0,0,.35), transparent 55%);
      pointer-events:none;
      opacity:.95;
    }

    .meta{
      position:relative;
      z-index:2;
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .hex{
      font-size:14px;
      font-weight:800;
      letter-spacing:.8px;
      text-transform:uppercase;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(10,10,14,.22);
      backdrop-filter: blur(6px);
    }

    .mini{
      font-size:12px;
      font-weight:700;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(10,10,14,.18);
      padding:8px 10px;
      border-radius:999px;
      color: rgba(255,255,255,.92);
      transition: background .15s ease;
      white-space:nowrap;
    }
    .mini:hover{ background: rgba(10,10,14,.28); }

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform: translateX(-50%);
      padding:10px 12px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(10,10,14,.65);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      color: rgba(255,255,255,.9);
      font-weight:650;
      font-size:12px;
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
      z-index:20;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-6px);
    }
    .toast .sw{
      width:12px;height:12px;border-radius:4px;
      border:1px solid rgba(255,255,255,.25);
    }

    @media (max-width: 980px){
      body{ overflow:auto; }
      .palette{
        position:relative;
        inset:auto;
        height:auto;
        grid-template-columns: 1fr;
      }
      .card{ min-height: 160px; }
      .topbar{ position:sticky; top:12px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brand">
      <div class="dot"></div>
      <div>
        <div class="title">Color Generator</div>
        <div class="hint">Pick a base color and press <span class="kbd">Space</span> to generateüé®</div>
      </div>
    </div>

    <div class="controls">
      <div class="pill">
        <span class="label">Color</span>
        <input id="baseColor" type="color" value="#FFB7C3" aria-label="Choose base color" />
        <span id="baseHex" class="kbd">#FFB7C3</span>
      </div>

      <label class="toggle" title="Generate only light/pastel colors">
        <input id="pastelOnly" type="checkbox" />
        <span>Pastel only</span>
      </label>

      <button id="btnGenerate" class="btn" type="button">Generate</button>
      <button id="btnRandomBase" class="btn" type="button">Random</button>
    </div>
  </div>

  <main id="palette" class="palette" aria-label="Color palette"></main>

  <div id="toast" class="toast" role="status" aria-live="polite">
    <span id="toastSw" class="sw"></span>
    <span id="toastText">Copied</span>
  </div>

<script>
(() => {
  const paletteEl = document.getElementById('palette');
  const baseInput = document.getElementById('baseColor');
  const baseHexEl = document.getElementById('baseHex');
  const pastelOnlyEl = document.getElementById('pastelOnly');
  const btnGenerate = document.getElementById('btnGenerate');
  const btnRandomBase = document.getElementById('btnRandomBase');

  const toast = document.getElementById('toast');
  const toastText = document.getElementById('toastText');
  const toastSw = document.getElementById('toastSw');
  let toastTimer = null;

  const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

  function hexToRgb(hex){
    const h = hex.replace('#','').trim();
    const full = h.length === 3 ? h.split('').map(c => c+c).join('') : h;
    const n = parseInt(full, 16);
    return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
  }

  function rgbToHex(r,g,b){
    const to = (x) => x.toString(16).padStart(2,'0');
    return ('#' + to(r) + to(g) + to(b)).toUpperCase();
  }

  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;

    const d = max - min;
    if (d !== 0){
      s = d / (1 - Math.abs(2*l - 1));
      switch(max){
        case r: h = 60 * (((g - b) / d) % 6); break;
        case g: h = 60 * (((b - r) / d) + 2); break;
        case b: h = 60 * (((r - g) / d) + 4); break;
      }
    }
    if (h < 0) h += 360;
    return { h, s: s*100, l: l*100 };
  }

  function hslToRgb(h,s,l){
    s/=100; l/=100;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r1=0,g1=0,b1=0;

    if (0 <= h && h < 60)        { r1=c; g1=x; b1=0; }
    else if (60 <= h && h < 120) { r1=x; g1=c; b1=0; }
    else if (120 <= h && h < 180){ r1=0; g1=c; b1=x; }
    else if (180 <= h && h < 240){ r1=0; g1=x; b1=c; }
    else if (240 <= h && h < 300){ r1=x; g1=0; b1=c; }
    else                          { r1=c; g1=0; b1=x; }

    const r = Math.round((r1 + m) * 255);
    const g = Math.round((g1 + m) * 255);
    const b = Math.round((b1 + m) * 255);
    return { r, g, b };
  }

  function normalizeHex(hex){
    if (!hex) return '#000000';
    let h = hex.trim();
    if (!h.startsWith('#')) h = '#' + h;
    if (h.length === 4) h = '#' + h[1]+h[1]+h[2]+h[2]+h[3]+h[3];
    return h.slice(0,7).toUpperCase();
  }

  function rand(min,max){ return Math.random()*(max-min)+min; }

  function showToast(text, colorHex){
    toastText.textContent = text;
    toastSw.style.background = colorHex;
    toast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => toast.classList.remove('show'), 1100);
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      return true;
    }catch{
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand('copy');
      ta.remove();
      return ok;
    }
  }

  // ---- Generation rules ----
  // Pastel mode: light + gentle.
  // Normal mode: still controlled (not too strong).
  function generateDerivedColors(baseHex, n=6, pastelOnly=false, forbiddenSet=new Set()){
    const {r,g,b} = hexToRgb(baseHex);
    const base = rgbToHsl(r,g,b);

    const results = new Set();
    const colors = [];
    let guard = 0;

    // Don‚Äôt allow returning the base color itself:
    forbiddenSet.add(baseHex.toUpperCase());

    while (colors.length < n && guard < 5000){
      guard++;

      // keep hue tight (same family)
      const hueJitter = pastelOnly ? rand(-8, 8) : rand(-10, 10);

      // Normal mode: never too strong -> cap saturation and avoid extreme darkness
      const satJitter   = pastelOnly ? rand(-10, 10) : rand(-12, 12);
      const lightJitter = pastelOnly ? rand(-8, 12)  : rand(-14, 14);

      const h = (base.h + hueJitter + 360) % 360;

      let s = clamp(base.s + satJitter, 18, 92);
      let l = clamp(base.l + lightJitter, 16, 92);

      if (pastelOnly){
        // Pastel constraints
        s = clamp(s, 18, 45);
        l = clamp(l, 72, 92);
      } else {
        // Controlled (non-pastel) constraints
        // (This is the ‚Äúnever too strong‚Äù part.)
        s = clamp(s, 22, 62);
        l = clamp(l, 28, 82);
      }

      const rgb = hslToRgb(h,s,l);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);

      if (!results.has(hex) && !forbiddenSet.has(hex)){
        results.add(hex);
        colors.push(hex);
      }
    }

    // worst-case fallback: fill with shifted hues (still safe)
    while (colors.length < n){
      const shift = (base.h + 25 * (colors.length + 1)) % 360;
      const s = pastelOnly ? 32 : 48;
      const l = pastelOnly ? 84 : 62;
      const rgb = hslToRgb(shift, s, l);
      const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
      if (!results.has(hex) && !forbiddenSet.has(hex)){
        results.add(hex);
        colors.push(hex);
      }
    }

    return colors;
  }

  function renderPalette(colors){
    paletteEl.innerHTML = '';
    colors.forEach((hex) => {
      const card = document.createElement('section');
      card.className = 'card';
      card.style.background = hex;
      card.setAttribute('data-hex', hex);
      card.setAttribute('aria-label', `Color ${hex}. Click to copy.`);

      const meta = document.createElement('div');
      meta.className = 'meta';

      const hexEl = document.createElement('div');
      hexEl.className = 'hex';
      hexEl.textContent = hex;

      const mini = document.createElement('div');
      mini.className = 'mini';
      mini.textContent = 'Copy';

      meta.appendChild(hexEl);
      meta.appendChild(mini);
      card.appendChild(meta);

      card.addEventListener('click', async () => {
        const ok = await copyToClipboard(hex);
        showToast(ok ? `Copied: ${hex}` : `Couldn‚Äôt copy üòÖ`, hex);
      });

      paletteEl.appendChild(card);
    });
  }

  function setBase(hex){
    const h = normalizeHex(hex);
    baseInput.value = h;
    baseHexEl.textContent = h;
    localStorage.setItem('baseColor', h);
  }

  function palettesEqual(a,b){
    if (!Array.isArray(a) || !Array.isArray(b)) return false;
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++){
      if (normalizeHex(a[i]) !== normalizeHex(b[i])) return false;
    }
    return true;
  }

  function generate(){
    const baseHex = normalizeHex(baseInput.value);
    setBase(baseHex);

    const pastelOnly = !!pastelOnlyEl.checked;

    // Read previous palette (to avoid repeating it)
    let prev = null;
    try{
      prev = JSON.parse(localStorage.getItem('lastPalette') || 'null');
      if (!Array.isArray(prev) || prev.length !== 6) prev = null;
    }catch{ prev = null; }

    // Make a forbidden set: avoid exact same colors as previous palette too
    const forbidden = new Set();
    if (prev){
      prev.forEach(c => forbidden.add(normalizeHex(c)));
    }

    let colors = null;

    // Try a few times to guarantee "not the same palette"
    for (let attempt=0; attempt<12; attempt++){
      const candidate = generateDerivedColors(baseHex, 6, pastelOnly, new Set(forbidden));

      // Strong guarantee: palette must not be identical to previous
      if (!prev || !palettesEqual(candidate, prev)){
        colors = candidate;
        break;
      }

      // If identical (ultra rare), expand forbidden a bit and retry
      candidate.forEach(c => forbidden.add(normalizeHex(c)));
    }

    // Final fallback (should never happen)
    if (!colors){
      colors = generateDerivedColors(baseHex, 6, pastelOnly, new Set(forbidden));
    }

    renderPalette(colors);
    localStorage.setItem('lastPalette', JSON.stringify(colors));
    localStorage.setItem('pastelOnly', pastelOnly ? '1' : '0');
  }

  function randomBase(){
    // nice random base: ranges that avoid neon
    const h = rand(0, 360);
    const s = rand(35, 70);
    const l = rand(40, 70);
    const {r,g,b} = hslToRgb(h,s,l);
    setBase(rgbToHex(r,g,b));
    generate();
  }

  // Events
  baseInput.addEventListener('input', () => {
    baseHexEl.textContent = normalizeHex(baseInput.value);
  });

  baseInput.addEventListener('change', generate);
  pastelOnlyEl.addEventListener('change', generate);
  btnGenerate.addEventListener('click', generate);
  btnRandomBase.addEventListener('click', randomBase);

  window.addEventListener('keydown', (e) => {
    const tag = (document.activeElement?.tagName || '').toLowerCase();
    const isTyping = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;

    if (!isTyping && (e.code === 'Space' || e.key === ' ')){
      e.preventDefault();
      generate();
    }
  }, { passive:false });

  // Boot
  const savedBase = localStorage.getItem('baseColor');
  const savedPastel = localStorage.getItem('pastelOnly');

  if (savedPastel != null) pastelOnlyEl.checked = savedPastel === '1';

  if (savedBase) setBase(savedBase);
  else setBase(baseInput.value);

  // Always generate once on load (and it will respect the anti-repeat rules)
  generate();
})();
</script>
</body>
</html>
